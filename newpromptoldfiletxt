
import { useEffect, useRef, useState } from 'react';
import './newPrompt.css'
import Upload from '../upload/Upload';
import { IKImage } from 'imagekitio-react';
import model from "../../lib/gemini";
import Markdown from "react-markdown";
import { useMutation, useQueryClient } from '@tanstack/react-query';

const NewPrompt = ({data}) => {
const [question,setQuestion]= useState("")
const [answer,setAnswer]= useState("")
const[img,setImg]=useState({
  isLoading:false,
  error:"",
  dbData:{},
  aiData:{},
});


const chat =  model.startChat({
    history: [
        {
          role: 'user',
          parts: [
            {
              text: "hello i have 2 dogs",
            }
          ],
        }
    ],
    generationConfig: {
    //OutputTokens: 100,

    },
});

  const endRef = useRef(null);
  const formRef = useRef(null);


  useEffect(()=>{
    endRef.current.scrollIntoView({behaviour:"smooth"});
  },[data, question,answer,img.dbData]);

  const queryClient = useQueryClient();

const mutation = useMutation({
  mutationFn: ()=>{
    return  fetch(`${import.meta.env.VITE_API_URL}/api/chats/${data._id}`,{
      
      method: "PUT",
      credentials:"include",
      headers:{
        "Content-Type": "application/json",
      },
      body:JSON.stringify({question: question.length? question: undefined,
        answer,
        img: img.dbData?.filePath || "",
      }),
    }
  ).then((res)=> res.json())
  },
  onSuccess:() => {
    //Invalidate and refetch
    queryClient.invalidateQueries({queryKey: ['chat',data._id]}).then(()=>{
      formRef.current.reset()
      setQuestion("")
      setAnswer("")
      setImg({
        isLoading:false,
        error:"",
        dbData:{},
        aiData:{},
    });
      
    });
  },
  onError:(err)=>{
    console.log(err);
  }
})

  const add = async (text,isInitial)=>{
    
   if(!isInitial) setQuestion(text);
    try{
    const result = await chat.sendMessageStream(
      Object.entries(img.aiData).length?[img.aiData,text]: [text]
    );
    let accumulatedText=""
    for await (const chunk of result.stream){
      const chunkText = chunk.text();
      console.log(chunkText);
      accumulatedText +=chunkText;
      setAnswer(accumulatedText||"sorry! couldn't find answer :(");
    }
    mutation.mutate();
  }catch(err){
      console.log(err);
  }
    
  };

  const domainKeywords = ["complexity","time","space",
    "optimization","divide","conquer","queue","stack",
    "tree","graph","array","linkedList","dynamic","greedy",
    "sorting","searching","notations","Algorithm", "Time complexity", "Space complexity", "Big O notation", "Divide and Conquer", "Dynamic Programming", "Greedy Algorithm", "Sorting", "Searching", "Graph", "Tree", "Array", "Linked List", "Stack", "Queue", "Recursion", "Iteration", "Optimization", "NP-Completeness", "Approximation algorithm", "Heuristic", "Asymptotic analysis", "Worst-case analysis", "Average-case analysis", "Best-case analysis", "Merge sort", "Quick sort", "Binary search", "Hashing", "Dijkstra's algorithm", "Bellman-Ford algorithm", "Floyd-Warshall algorithm", "Topological sort", "Minimum spanning tree", "Shortest path", "Algorithm design", "Algorithm analysis", "Computational complexity", "Efficient algorithm", "Algorithmic problem-solving", "Backtracking",

     "Process","Thread","Process management",
     "Thread management","Scheduling","Context switching",
    "Interrupt handling","Memory management","Virtual memory",
    "Paging","segmentation","File system","File management",
    "Input/Output (I/O) management","Device driver","Interrupt",
    "System call","Kernel","Operating system","Process synchronization",
    "Deadlock","Semaphore","Monitor","Mutual exclusion",
    "CPU scheduling","Priority scheduling","Round-robin scheduling",
    "Multitasking","Multithreading","Multiprocessing","Virtualization",
    "Containerization","Security","Access control","Authentication",
    "Authorization","Booting","Bootstrap loader","System configuration",
    "Performance optimization",
  
    "Database", "Schema", "Entity", "Attribute", "Relation",
     "Tuple", "SQL", "Query", "Index", "Normalization", 
     "Denormalization", "ACID", "Transaction", "Locking",
      "CRUD", "Data integrity", "Data security", 
      "Access control", "Authentication", "Authorization",
       "Relational database", "NoSQL database", "Distributed database",
        "Cloud database", "Data warehousing", "Data mining", "ETL", 
        "Query optimization", "Caching", "Join", "Subquery", 
        "Aggregate functions", "Primary key", "Foreign key", "Unique key", "Data modeling", "Database design", "Database administration", "Backup", 
        "Recovery", "Scalability",
      
      "Class", "Object", "Inheritance", "Polymorphism", "Encapsulation", "Abstraction", "Interface", "Abstract class", "Method", "Variable", "Data type",
       "Operator", "Control structure", "Exception handling", "Multithreading", "Synchronization", "Generics", "Lambda expression", "Java Virtual Machine",
        "Garbage collection", "Reflection", "Annotations", "Static", "Final", "Access modifiers", "Constructor", "Overloading", "Overriding", 
        "Inheritance hierarchy", "Method overriding", "Method overloading", "JavaBeans", "Servlet", "JSP", "JAX-RS", "JDBC", "Hibernate", "Spring", 
        "JavaFX", "Swing", "Applet",
      
      "Network", "Protocol", "TCP/IP", "HTTP", "FTP", "SSH", "DNS", "IP address", "MAC address", "Router", "Switch", "Hub", "LAN", "WAN", "Wi-Fi", 
      "Ethernet", "Packet switching", "Circuit switching", "Firewall", "VPN", "Encryption", "Decryption", "Authentication", "Authorization", 
      "Network security", "Network topology", "Client-server model", "Peer-to-peer model", "Transport layer", "Network layer", "Data link layer", 
      "Physical layer", "Socket programming", "Network performance", "Bandwidth", "Latency", "Jitter", "Packet loss", "Network architecture", 
      "Subnetting", "Routing"]; // Add more as needed

  const isInDomain = (text) => {
  return domainKeywords.some(word => text.toLowerCase().includes(word));
};

  const handleSubmit = async(e)=>{
    e.preventDefault();

    const text = e.target.text.value;
    if(!text) return;

    // setQuestion("");
    // setAnswer("");
    
    if (!isInDomain(text)) {
      setAnswer(" I can only help with your academic questions. Please rephrase your query. ");
      setQuestion(text); // Optional: to show what the user asked
      formRef.current.reset();
      return;
    }
    setQuestion(text); 
    add(text,false);
 
  };
//IN PRODUCTION NOT NEEDED
  const hasRun = useRef(false)
  useEffect(()=> {
    if(!hasRun.current){
    if(data?.history?.length === 1){
      add(data.history[0].parts[0].text, true);
    }
  }hasRun.current=true;
  },[]);
    
  return (
    <>
    {/*add new chat*/}
    {img.isLoading && <div className='' >Loading...</div>}
    {img.dbData?.filePath && (
      <IKImage
      urlEndpoint={import.meta.env.VITE_IMAGE_KIT_ENDPOINT}
      path={img.dbData?.filePath}
      width="380"
      transformation={[{width:380}]}
      />
    )}
    {question && <div className='message user'>{question}</div>}
    {answer && <div className='message ai'><Markdown>{answer}</Markdown></div>}
   
    <div className='endChat' ref={endRef}></div>
    
        <form className='newForm' onSubmit={handleSubmit} ref={formRef}>

            <Upload setImg={setImg}/>
            <input id='file' type='file' multiple={false}  hidden/>
            <input type='text'name='text' placeholder='Ask anything...'/>
            <button>
            <img src="/arrow.png" alt=""/>
            </button>
        </form>
    </>
  );
};

export default NewPrompt;